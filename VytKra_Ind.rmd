---
title: "Individualus Darbas"
author: "Vytautas Kraujalis"
date: '2021-12-05'
output: 
  word_document:
    toc: true 
    toc_depth: 3
    number_sections: true
    highlight: tango
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Reikalingi paketai
```{r}
library(ggplot2)
library(dplyr)
library(ggfortify)
library(lubridate)
library(ggthemes)
library(RColorBrewer)
library(scales)
library(forecast)
library(zoo)
```

Naudosime JAV saldainių gaminimo duomenų imtį.
```{r}
data <- read.csv("candy_production.csv") %>% 
   rename(data = observation_date, saldainiai = IPG3113N)
```

# Uzd 1
Atlikite pirminę duomenų apžvalgą, pašalinkite išskirtis, atsižvelkite į praleistas reikšmes, ir pan.

```{r}
nrow(data)
```

Duomenų imtis sudaryta iš 548 stebėjimų.

```{r}
sum(is.na(data$saldainiai))
```

Duomenų imtyje neturime nei vienos praleistos reikšmės

```{r}
data %>% 
   group_by(metai = year(as.Date(data))) %>% 
   summarise(n = n())
```

Matom, jog turime duomenis nuo 1972 m. iki 2017 m. Visi metai turi po 12 stebėjimų (mėnesiniai duomenys), tik paskutiniai 2017 metai turi 8 stebėjimus.

```{r}
boxplot(data$saldainiai)
```

Stačiakampė diagrama neparodo, jog mūsų duomenyse būtų kokių nors tai išskirčių.

```{r}
summary(data)
```

Mažiausia reikšmė - 50.67, didžiausia - 139.92 Vidurkis ir mediana yra panašūs, atitinkamai 100.66 ir 102.28.

# Uzd. 2
## Laiko eilutė
```{r}
saldainiai.ts <- ts(data$saldainiai, start = c(1972, 1), frequency = 12)
saldainiai.ts %>% 
   autoplot() +
   theme_minimal() +
   labs(title = "JAV saldainių produkcija")
```

Duomenys akivaizdžiai turi sezoniškumą ir trendą

## Autokoreliacinė funkcija
```{r}
Acf(saldainiai.ts)
```

Autokoreliacijos grafikas parodo, jog mūsų laiko eilutė nėra stacionari, kadangi ties visomis lag reikšmėmis viršijame 95% pasikliautinuosius intervalus, kurie nurodo, jog duomenys skiriasi nuo baltojo triukšmo.

## Spektrinio tankio funkcija
```{r}
spectrum(saldainiai.ts)
```

Kadangi spektriniame grafike matome "pikus" ties 1, 2, 3 ir t.t. dažniais, galime daryti išvadą, jog mūsų duomenyse yra metinis sezoniškumas.

Pasižiūrime, ar mūsų spėjimas yra teisingas:
```{r}
saldainiai.ts %>% 
   window(start = c(1990, 1), end = c(1992, 12)) %>% 
   autoplot() +
   theme_minimal() +
   labs(title = "JAV saldainių produkcija", subtitle = "1990 m. - 1992 m.")
```

Akivaizdžiai matome, jog mūsų spėjimas galimai yra tiesa, matosi, jog metai iš metų kartojasi ta pati tendencija.


# Uzd 3
```{r}
saldainiai.ts %>%
   stl(s.window = "periodic") %>%
   autoplot(range.bars = F) + 
   labs(x = "Data", 
        title = "JAV saldainių produkcijos laiko eilutės dekompozicija",
        subtitle = "Duomenys nuo 1972-01 mėn. iki 2017-08 mėn.") +
   theme_minimal() +
   theme(text = element_text(size = 18))
```

Kaip jau darėmė išvadą prieš tai, duomenyse matomas akivaizdus metinis sezoniškumas. Tą parodo ir dekompozicijos sezoniškumo grafikas.

# Uzd. 4
Prognozuosime 4 laiko momentus (4 mėnesius) taip užpildydami 2017 metus.
## 4.1
### Vidurkio metodas
```{r}
mean_ts <- meanf(saldainiai.ts, h = 4, level = c(90, 95, 99))

accuracy(mean_ts)
```

```{r}
plot_fx(
   mean_ts,
   year = 2017,
   freq.place = 1,
   date.breaks = "months",
   date.format = "%Y%m",
   x.title = "Mėnuo",
   y.title = "Saldainių produkcija",
   main.title = "JAV saldainių produkcijos prognozė Vidurkio metodu",
   caption = "Modelis buvo apmokytas ant mėnesinių duomenų"
)
```





























Function which will be used later for forecast plot
```{r}
# Header ----
# Details:     Function data inpuits are defined as follows:
#              fx.dat         = forecast data object with 3 predictive intervals
#              year           = year from which the time series will be subseted
#              freq.place     = day / week / month / year from which the time series will be subseted
#              PI             = logical if predictive intervals are drawn
#              shade.cols     = character string; 3 shade colors for predictive intervals
#              line.cols      = character strine; 3 line colors for training, fitted and forecast data
#              date.breaks    = character string; such as "3 months", "1 year"
#              data.format    = x-axis date format
#              main.title     = character string; main plot title
#              sub.title      = character string; plot sub title
#              caption        = character string; caption
#              x.title        = character string; x-axis title
#              y.title        = character string; y-axis title
#
##-------------------------------------------------------------------------------------------##

# theme for forecast data objects
theme.fxdat <- theme_gdocs() +
     theme(plot.title = element_text(size = 15),
           plot.subtitle = element_text(size = 11),
           plot.caption = element_text(size = 9, hjust = 0, vjust = 0, colour = "grey50"),
           axis.title.y = element_text(face = "bold", color = "gray30"),
           axis.title.x = element_text(face = "bold", color = "gray30", vjust = -1),
           panel.background = element_rect(fill = "grey95", colour = "grey75"),
           panel.border = element_rect(colour = "grey75"),
           panel.grid.major.y = element_line(colour = "white"),
           panel.grid.minor.y = element_line(colour = "white", linetype = "dotted"),
           panel.grid.major.x = element_line(colour = "white"),
           panel.grid.minor.x = element_line(colour = "white", linetype = "dotted"),
           strip.background = element_rect(size = 1, fill = "white", colour = "grey75"),
           strip.text.y = element_text(face = "bold"),
           axis.line = element_line(colour = "grey75"))

# function for using ggplot2 for forecast objects
plot_fx <- function(fx.dat,
                    year = NA,
                    freq.place = NA,
                    PI = TRUE,
                    line.cols = NA,
                    shade.cols = NA,
                    date.breaks = NA,
                    date.format = "%Y-%b",
                    main.title = NA,
                    sub.title = NA,
                    caption = NA,
                    x.title = NA,
                    y.title = NA){

   # manage package libraries
     pkgs <- c("dplyr",
               "ggplot2",
               "RColorBrewer",
               "scales",
               "forecast",
               "zoo")
     attached <- search()
     attached_pkgs <- attached[grepl("package", attached)]
     need_to_attach <- pkgs[which(!pkgs %in% gsub("package:", "", attached_pkgs))]
     if (length(need_to_attach) > 0) {
          for (i in 1:length(need_to_attach)) {
               require(need_to_attach[i], character.only = TRUE)
          }
     }

     # data input testing and formatting
     if (class(fx.dat) != "forecast") {
          stop("forecast data object required", call. = FALSE)
     }
     if (is.na(line.cols[1])) {
          line.cols = c("black", "darkcyan", "goldenrod1")
     }
     if (length(line.cols) != 3) {
          stop("length of line.cols not equal to 3", call. = FALSE)
     }
     if (PI == TRUE) {
          pi.levels <- fx.dat$level
          n.levels <- length(pi.levels)
          if (is.na(shade.cols)) {
               shade.cols = brewer.pal(n.levels, "PuBuGn")
               }
          if (n.levels != length(shade.cols)) {
               stop("length of shade.cols not equal to number of predictive intervals",
                    call. = FALSE)
          }
     }
     if (is.na(date.breaks)) {
          print("date.breaks to set to '6 months' absent user input")
          date.breaks <- "6 months"
     }

     # define dataframe with training (x), forecast (y) and interval (pi) data
     
     
      original.ts <- window(fx.dat$x, c(year, freq.place))
      fitted.ts <- window(fx.dat$fitted, c(year, freq.place))
      forecast.ts.mean <- fx.dat$mean
      original.dates <- format(date_decimal(as.numeric(time(original.ts, offset = 0.5))), format = "%Y-%m-%d")
      forecast.dates <- format(date_decimal(as.numeric(time(forecast.ts.mean, offset = 0.5))), format = "%Y-%m-%d")
      
      len.x <- length(original.ts)
      len.y <- length(forecast.ts.mean)
      
      sub.title <- paste0("Showing actual data from ", min(original.dates), " - ", max(original.dates), " and forecast for ", min(forecast.dates), " - ", max(forecast.dates))

     df <- data.frame(
            date = as.Date(c(original.dates, forecast.dates)),
            x = c(original.ts, rep(NA, len.y)),
            fitted = c(fitted.ts, rep(NA, len.y)),
            forecast = c(rep(NA, len.x), forecast.ts.mean),
            lo.80 = c(rep(NA, len.x), fx.dat$lower[, 1]),
            up.80 = c(rep(NA, len.x), fx.dat$upper[, 1]),
            lo.95 = c(rep(NA, len.x), fx.dat$lower[, 2]),
            up.95 = c(rep(NA, len.x), fx.dat$upper[, 2]),
            lo.99 = c(rep(NA, len.x), fx.dat$lower[, 3]),
            up.99 = c(rep(NA, len.x), fx.dat$upper[, 3])
     )

     # plot training, fitted and forecast data
     ggplot(df,  aes(date, x)) +
          geom_line(aes(colour = "Training")) +
          geom_line(data = df, aes(date, fitted, colour = "Fitted"), size = 0.75) +
          geom_ribbon(data = df, aes(date, ymin = lo.99, ymax = up.99, fill = "99%")) +
          geom_ribbon(data = df, aes(date, ymin = lo.95, ymax = up.95, fill = "95%")) +
          geom_ribbon(data = df, aes(date, ymin = lo.80, ymax = up.80, fill = "80%")) +
          geom_line(data = df, aes(date, forecast, colour = "Forecast"), size = 0.75) +
          geom_point(data = df, aes(date, forecast, colour = "Forecast"), size = 1) +
          geom_point(size = 1) +
          scale_x_date(breaks = seq(df$date[1], df$date[length(df$date)],
                                    by = date.breaks),
                       date_labels = date.format) +
          scale_colour_manual(name = "Model Data",
                              values = c("Training" = line.cols[1],
                                         "Fitted" = line.cols[2],
                                         "Forecast" = line.cols[3]),
                              breaks = c("Training", "Fitted", "Forecast")) +
          scale_fill_manual(name = "Forecast Intervals",
                            values = c("99%" = shade.cols[1], "95%" = shade.cols[2],
                                       "80%" = shade.cols[3])) +
          guides(colour = guide_legend(order = 1), fill = guide_legend(order = 2)) +
          labs(title = main.title,
               subtitle = sub.title,
               caption = caption,
               x = x.title,
               y = y.title) +
          theme.fxdat
}
```


















https://www.kaggle.com/goldens/candy-production-time-series-analysis
https://www.kaggle.com/grosvenpaul/eda-and-time-series-modeling

